<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>게시글 상세</title>
  <link rel="stylesheet" href="/css/style.css"/>
  <!-- Highlight.js CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
</head>
<body>
  <div class="wrap">
    <!-- 뒤로가기 버튼 -->
    <button class="back-button" onclick="history.back()">←</button>
    <div class="post-detail-container">
      <!-- 게시글 제목 -->
      <div class="post-title-section">
        <h1 id="title" class="post-title">제목</h1>
      </div>
      
      <!-- 작성자 정보 및 액션 -->
      <div class="post-author-section">
        <div class="author-info">
          <img id="authorProfileImg" class="author-profile-img" src="/assets/images/account_circle.png" alt="프로필">
          <div class="author-details">
            <div id="author" class="author-name">작성자</div>
            <div id="publishedAt" class="publish-date">2023.11.03</div>
          </div>
        </div>
        <div class="post-actions">
          <button id="btnEdit" class="btn-edit">수정</button>
          <button id="btnDelete" class="btn-delete">삭제</button>
        </div>
      </div>
      
      <!-- 포스트 이미지들 -->
      <div id="images" class="post-images-section">
        <!-- 이미지들이 여기에 동적으로 추가됩니다 -->
      </div>
      
      <!-- 포스트 텍스트 -->
      <div class="post-content-section">
        <div id="content" class="content-text">게시글 내용</div>
      </div>
      
      <!-- 통계 정보 -->
      <div class="post-stats-section">
        <div class="card-post-count-info">
          <button id="btnLike" class="card-post-lcv like-btn">
            <img class="card-post-icon" src="/assets/images/like.png" alt="like" />
            <div id="likeCount" class="card-post-count">0</div>
          </button>
          <div class="card-post-lcv">
            <img class="card-post-icon" src="/assets/images/comment.png" alt="comment" />
            <div id="commentCount" class="card-post-count">0</div>
          </div>
          <div class="card-post-lcv">
            <img class="card-post-icon" src="/assets/images/view.png" alt="view" />
            <div id="viewCount" class="card-post-count">0</div>
          </div>
        </div>
      </div>
      
      <!-- 댓글 섹션 -->
      <div class="comments-section">
        
        <!-- 댓글 입력 -->
        <div class="comment-input-section">
          <textarea id="commentInput" class="comment-input" placeholder="댓글을 입력하세요"></textarea>
          <button id="btnCommentSubmit" class="btn-comment-submit" disabled>등록</button>
        </div>
        
        <!-- 댓글 목록 -->
        <div id="commentsList" class="comments-list">
          <!-- 댓글들이 여기에 동적으로 추가됩니다 -->
        </div>
        
        <!-- 무한 스크롤 로딩 인디케이터 -->
        <div id="loadingIndicator" class="loading-indicator" style="display: none;">
          <div class="spinner"></div>
          <span>댓글을 불러오는 중...</span>
        </div>
      </div>
    </div>
  </div>

  <!-- 삭제 확인 모달 -->
  <div id="deleteModal" class="modal">
    <div class="modal-content">
      <h3>게시글 삭제</h3>
      <p>정말로 이 게시글을 삭제하시겠습니까?</p>
      <div class="modal-actions">
        <button id="btnConfirmDelete" class="btn-confirm">확인</button>
        <button id="btnCancelDelete" class="btn-cancel">취소</button>
      </div>
    </div>
  </div>

  <!-- 댓글 삭제 확인 모달 -->
  <div id="commentDeleteModal" class="modal">
    <div class="modal-content">
      <h3>댓글 삭제</h3>
      <p>정말로 이 댓글을 삭제하시겠습니까?</p>
      <div class="modal-actions">
        <button id="btnConfirmCommentDelete" class="btn-confirm">확인</button>
        <button id="btnCancelCommentDelete" class="btn-cancel">취소</button>
      </div>
    </div>
  </div>

  <script src="/js/auth.js"></script>
  <script src="/js/api.js"></script>
  <script src="/js/aside.js"></script>
  <script src="/js/ui.js"></script>
  <!-- Marked.js for markdown parsing -->
  <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
  <!-- Highlight.js for syntax highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>
    renderHeader();
    if(!requireLogin('/login')){}
    
    // 프로필 이미지 설정
    const currentUser = Auth.profile();
    if(currentUser?.imageUrl) {
      document.querySelector('.profile_circle').src = currentUser.imageUrl;
    }
    
    // Marked.js 설정 - highlight.js와 연동
    if (typeof marked !== 'undefined') {
      marked.setOptions({
        highlight: function(code, lang) {
          if (lang && typeof hljs !== 'undefined') {
            try {
              return hljs.highlight(code, { language: lang }).value;
            } catch (err) {
              return hljs.highlightAuto(code).value;
            }
          }
          if (typeof hljs !== 'undefined') {
            return hljs.highlightAuto(code).value;
          }
          return code;
        },
        breaks: true,
        gfm: true
      });
    }
    
    const params = new URLSearchParams(location.search);
    const postId = Number(params.get('id'));
    let isEditingComment = false;
    let editingCommentId = null;
    let deleteCommentId = null;
    let isLoadingComments = false;
    let commentCurrentPage = 0;
    const commentPageSize = 5;
    let hasMoreComments = true;
    let isInitialLoadComplete = false;
    let scrollDebounceTimer = null;
    let lastScrollY = 0;
    
    // 숫자 포맷팅 함수 (1k, 10k, 100k)
    function formatNumber(num) {
      if (num >= 100000) return Math.floor(num / 1000) + 'k';
      if (num >= 10000) return Math.floor(num / 1000) + 'k';
      if (num >= 1000) return Math.floor(num / 1000) + 'k';
      return num.toString();
    }
    
    // 좋아요 아이콘 업데이트
    function updateLikeIcon(isLiked) {
      const likeBtn = document.getElementById('btnLike');
      const likeImg = likeBtn.querySelector('img');
      if (isLiked) {
        likeImg.src = '/assets/images/like_on.png';
        likeBtn.classList.add('liked');
      } else {
        likeImg.src = '/assets/images/like.png';
        likeBtn.classList.remove('liked');
      }
    }
    
    // 게시글 로드
    async function loadPost() {
      try {
        const res = await apiFetch('/posts/' + postId + '?increaseView=true');
        const p = res.data;
        
        
        // 제목
        document.getElementById('title').textContent = p.title;
        
        // 작성자 정보
        document.getElementById('author').textContent = p.author?.nickname || 'Anonymous';
        document.getElementById('authorProfileImg').src = p.author?.profileImageUrl || '/assets/images/account_circle.png';
        
        // 마지막 업데이트 시간 포맷팅
        const updatedAt = new Date(p.publishedAt);
        const now = new Date();
        
        // 같은 날짜인지 확인 (오늘인지 확인)
        const isToday = updatedAt.getFullYear() === now.getFullYear() &&
                        updatedAt.getMonth() === now.getMonth() &&
                        updatedAt.getDate() === now.getDate();
        
        let dateText;
        if (isToday) {
          dateText = '오늘';
        } else {
          // 오늘이 아니면 날짜와 시간을 함께 표기
          dateText = updatedAt.toLocaleString('ko-KR', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
          });
        }
        
        document.getElementById('publishedAt').textContent = dateText;
        
        // 내가 쓴 글인지 확인하여 수정/삭제 버튼 표시/숨김
        const currentUserId = Auth.userId();
        const isMyPost = currentUserId && p.author?.id === currentUserId;
        const postActions = document.querySelector('.post-actions');
        
        if (isMyPost) {
          postActions.style.display = 'flex';
        } else {
          postActions.style.display = 'none';
        }
        
        // 통계 정보
        document.getElementById('viewCount').textContent = formatNumber(p.viewCount || 0);
        document.getElementById('commentCount').textContent = formatNumber(p.commentCount || 0);
        document.getElementById('likeCount').textContent = formatNumber(p.likeCount || 0);
        
        // 좋아요 버튼 상태 업데이트
        updateLikeIcon(p.isLiked);
        
        // 이미지 표시
        const imagesContainer = document.getElementById('images');
        imagesContainer.innerHTML = '';
        if (p.images && p.images.length > 0) {
          p.images.forEach(img => {
            const imgEl = document.createElement('img');
            imgEl.src = img.imageUrl;
            imgEl.className = 'post-image';
            imagesContainer.appendChild(imgEl);
          });
        }
        
        // 게시글 내용 - 마크다운 파싱 및 구문 강조 적용
        const contentElement = document.getElementById('content');
        if (typeof marked !== 'undefined' && p.content) {
          // 마크다운을 HTML로 변환
          const htmlContent = marked.parse(p.content);
          contentElement.innerHTML = htmlContent;
          
          // highlight.js 적용 (marked가 자동으로 적용하지만, 추가로 보장)
          if (typeof hljs !== 'undefined') {
            contentElement.querySelectorAll('pre code').forEach((block) => {
              hljs.highlightElement(block);
            });
          }
        } else {
          // 라이브러리가 로드되지 않은 경우 일반 텍스트로 표시
          contentElement.textContent = p.content;
        }
        
        // 댓글 초기 로드
        await loadComments();
      } catch (e) {
        alert('게시글을 불러오는데 실패했습니다: ' + e.message);
      }
    }
    
    // 댓글 렌더링 헬퍼 함수
    function renderComment(comment) {
      const commentEl = document.createElement('div');
      commentEl.className = 'comment-item';
      commentEl.dataset.commentId = comment.id;
      
      // 현재 사용자가 댓글 작성자인지 확인
      const currentUserId = Auth.userId();
      const isMyComment = currentUserId && comment.author?.id === currentUserId;
      
      commentEl.innerHTML = `
        <div class="comment-content">
          <div class="comment-author">${comment.author?.nickname || 'Anonymous'}</div>
          <div class="comment-text" data-original="${comment.content.replace(/"/g, '&quot;')}">${comment.content}</div>
          <textarea class="comment-edit-input" style="display: none;">${comment.content}</textarea>
          <div class="comment-date">${new Date(comment.publishedAt).toLocaleString('ko-KR')}</div>
        </div>
        <div class="comment-actions" style="display: ${isMyComment ? 'flex' : 'none'}">
          <button class="btn-comment-edit" data-comment-id="${comment.id}">수정</button>
          <button class="btn-comment-save" data-comment-id="${comment.id}" style="display: none;">저장</button>
          <button class="btn-comment-cancel" data-comment-id="${comment.id}" style="display: none;">취소</button>
          <button class="btn-comment-delete" data-comment-id="${comment.id}">삭제</button>
        </div>
      `;
      return commentEl;
    }
    
    // 댓글 로드 (무한 스크롤)
    async function loadComments(reset = false) {
      // 동시 로딩 방지: 이미 로딩 중이거나 더 이상 로드할 댓글이 없으면 중단
      if (isLoadingComments || (!reset && !hasMoreComments)) return;
      
      isLoadingComments = true;
      if (reset) {
        document.getElementById('commentsList').innerHTML = '';
        commentCurrentPage = 0;
        hasMoreComments = true;
        isInitialLoadComplete = false;
      }
      
      try {
        showLoadingIndicator();
        // 현재 페이지 번호로 API 호출 (페이지는 0부터 시작)
        const res = await apiFetch(`/posts/${postId}/comments?page=${commentCurrentPage}&size=${commentPageSize}`);
        const commentsData = res.data?.comments || [];
        const pagination = res.data?.pagination || {};
        
        if (commentsData.length === 0) {
          hasMoreComments = false;
          hideLoadingIndicator();
          if (commentCurrentPage === 0) {
            // 첫 페이지에서 댓글이 없으면 메시지 표시
            const commentsList = document.getElementById('commentsList');
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'empty-comments';
            emptyMessage.textContent = '댓글이 없습니다.';
            commentsList.appendChild(emptyMessage);
          }
          // 초기 로드 완료 표시 (댓글이 없어도 초기 로드는 완료됨)
          isInitialLoadComplete = true;
          return;
        }
        
        const commentsList = document.getElementById('commentsList');
        
        // 기존 빈 메시지 제거
        const emptyMessage = commentsList.querySelector('.empty-comments');
        if (emptyMessage) {
          emptyMessage.remove();
        }
        
        // 기존 끝 메시지 제거 (reset 시)
        const endMessage = commentsList.querySelector('.end-message');
        if (endMessage) {
          endMessage.remove();
        }
        
        // 댓글 렌더링 (한 페이지씩만 추가)
        commentsData.forEach(comment => {
          const commentEl = renderComment(comment);
          commentsList.appendChild(commentEl);
        });
        
        // 페이지 번호 증가 (다음 페이지 로드를 위해)
        commentCurrentPage++;
        
        // 더 이상 댓글이 없으면 마지막 메시지 표시
        if (!pagination.has_more) {
          hasMoreComments = false;
          const endMsg = document.createElement('div');
          endMsg.className = 'end-message';
          endMsg.innerHTML = '<p>마지막 댓글입니다.</p>';
          commentsList.appendChild(endMsg);
        }
        
        hideLoadingIndicator();
        
        // 초기 로드 완료 표시 (첫 페이지 로드 후에만)
        if (!isInitialLoadComplete && commentCurrentPage === 1) {
          isInitialLoadComplete = true;
        }
      } catch (e) {
        console.error('댓글을 불러오는데 실패했습니다:', e);
        hideLoadingIndicator();
        // 에러 발생 시에도 초기 로드는 완료된 것으로 표시 (무한 대기 방지)
        if (!isInitialLoadComplete) {
          isInitialLoadComplete = true;
        }
      } finally {
        isLoadingComments = false;
      }
    }
    
    // 댓글 무한 스크롤 감지
    function setupCommentScrollListener() {
      window.addEventListener('scroll', () => {
        // 초기 로드가 완료되지 않았으면 스크롤 리스너 무시 (강화된 보호)
        if (!isInitialLoadComplete) {
          return;
        }
        
        // 이미 로딩 중이거나 더 이상 로드할 댓글이 없으면 무시
        if (isLoadingComments || !hasMoreComments) {
          return;
        }
        
        // 디바운싱: 300ms 내에 여러 스크롤 이벤트가 발생해도 마지막 이벤트만 처리
        if (scrollDebounceTimer) {
          clearTimeout(scrollDebounceTimer);
        }
        
        scrollDebounceTimer = setTimeout(() => {
          // 다시 한번 체크 (디바운싱 중 상태가 변경될 수 있음)
          if (!isInitialLoadComplete || isLoadingComments || !hasMoreComments) {
            return;
          }
          
          const commentsList = document.getElementById('commentsList');
          if (!commentsList) {
            return;
          }
          
          // 스크롤이 실제로 아래로 내려갔는지 확인
          const currentScrollY = window.scrollY || window.pageYOffset;
          if (currentScrollY <= lastScrollY) {
            lastScrollY = currentScrollY;
            return;
          }
          lastScrollY = currentScrollY;
          
          const commentsListRect = commentsList.getBoundingClientRect();
          const windowHeight = window.innerHeight;
          
          // 댓글 목록이 화면에 보이고, 댓글 목록의 하단이 화면 하단에 가까워지면 추가 로드
          // 300px 여유를 두어 미리 로드
          if (commentsListRect.bottom <= windowHeight + 300) {
            loadComments();
          }
        }, 300);
      });
    }
    
    // 로딩 인디케이터 표시/숨김
    function showLoadingIndicator() {
      document.getElementById('loadingIndicator').style.display = 'flex';
    }
    
    function hideLoadingIndicator() {
      document.getElementById('loadingIndicator').style.display = 'none';
    }
    
    // 좋아요 토글
    document.getElementById('btnLike').addEventListener('click', async () => {
      try {
        const res = await apiFetch('/posts/' + postId + '/like', { method: 'POST' });
        const data = res?.data || {};
        const likeBtn = document.getElementById('btnLike');
        const likeCountEl = document.getElementById('likeCount');

        const likeCount = typeof data.like === 'number' ? data.like : 0;
        likeCountEl.textContent = formatNumber(likeCount);

        updateLikeIcon(data.isLiked);
      } catch (e) {
        alert('좋아요 처리에 실패했습니다: ' + e.message);
      }
    });
    
    // 댓글 입력 처리
    const commentInput = document.getElementById('commentInput');
    const commentSubmitBtn = document.getElementById('btnCommentSubmit');
    
    commentInput.addEventListener('input', () => {
      const hasText = commentInput.value.trim().length > 0;
      commentSubmitBtn.disabled = !hasText;
    });
    
    commentSubmitBtn.addEventListener('click', async () => {
      const content = commentInput.value.trim();
      if (!content) return;
      
      try {
        // 댓글 등록
        await apiFetch('/posts/' + postId + '/comments', {
          method: 'POST',
          body: JSON.stringify({ content })
        });
        
        commentInput.value = '';
        commentSubmitBtn.disabled = true;
        // 댓글 작성 후 첫 페이지부터 다시 로드
        commentCurrentPage = 0;
        hasMoreComments = true;
        await loadComments(true); // 댓글 목록 새로고침
        await loadPost();
      } catch (e) {
        alert('댓글 처리에 실패했습니다: ' + e.message);
      }
    });
    
    // 댓글 수정 - 인라인 편집 모드로 전환
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('btn-comment-edit')) {
        const commentId = e.target.dataset.commentId;
        const commentItem = e.target.closest('.comment-item');
        const commentTextEl = commentItem.querySelector('.comment-text');
        const commentEditInput = commentItem.querySelector('.comment-edit-input');
        const btnEdit = commentItem.querySelector('.btn-comment-edit');
        const btnSave = commentItem.querySelector('.btn-comment-save');
        const btnCancel = commentItem.querySelector('.btn-comment-cancel');
        const btnDelete = commentItem.querySelector('.btn-comment-delete');
        
        // 텍스트 숨기고 입력창 표시
        commentTextEl.style.display = 'none';
        commentEditInput.style.display = 'block';
        commentEditInput.focus();
        
        // 버튼 전환
        btnEdit.style.display = 'none';
        btnSave.style.display = 'inline-block';
        btnCancel.style.display = 'inline-block';
        btnDelete.style.display = 'none';
      }
      
      // 저장 버튼 클릭
      if (e.target.classList.contains('btn-comment-save')) {
        const commentId = e.target.dataset.commentId;
        const commentItem = e.target.closest('.comment-item');
        const commentEditInput = commentItem.querySelector('.comment-edit-input');
        const newContent = commentEditInput.value.trim();
        
        if (!newContent) {
          alert('댓글 내용을 입력해주세요.');
          return;
        }
        
        // 서버에 수정 요청
        apiFetch(`/posts/${postId}/comments/${commentId}`, {
          method: 'PATCH',
          body: JSON.stringify({ content: newContent })
        }).then(async () => {
          commentCurrentPage = 0;
          hasMoreComments = true;
          await loadComments(true);
          await loadPost();
        }).catch(err => {
          alert('댓글 수정에 실패했습니다: ' + err.message);
        });
      }
      
      // 취소 버튼 클릭
      if (e.target.classList.contains('btn-comment-cancel')) {
        const commentItem = e.target.closest('.comment-item');
        const commentTextEl = commentItem.querySelector('.comment-text');
        const commentEditInput = commentItem.querySelector('.comment-edit-input');
        const btnEdit = commentItem.querySelector('.btn-comment-edit');
        const btnSave = commentItem.querySelector('.btn-comment-save');
        const btnCancel = commentItem.querySelector('.btn-comment-cancel');
        const btnDelete = commentItem.querySelector('.btn-comment-delete');
        const originalContent = commentTextEl.dataset.original;
        
        // 원래 내용으로 복원
        commentEditInput.value = originalContent;
        
        // 입력창 숨기고 텍스트 표시
        commentEditInput.style.display = 'none';
        commentTextEl.style.display = 'block';
        
        // 버튼 전환
        btnEdit.style.display = 'inline-block';
        btnSave.style.display = 'none';
        btnCancel.style.display = 'none';
        btnDelete.style.display = 'inline-block';
      }
    });
    
    // 댓글 삭제
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('btn-comment-delete')) {
        deleteCommentId = e.target.dataset.commentId;
        document.getElementById('commentDeleteModal').style.display = 'flex';
      }
    });
    
    // 게시글 삭제
    document.getElementById('btnDelete').addEventListener('click', () => {
      document.getElementById('deleteModal').style.display = 'flex';
    });
    
    // 모달 이벤트
    document.getElementById('btnConfirmDelete').addEventListener('click', async () => {
      try {
        await apiFetch('/posts/' + postId, { method: 'PUT' });
        alert('게시글이 삭제되었습니다.');
        location.href = '/';
      } catch (e) {
        alert('게시글 삭제에 실패했습니다: ' + e.message);
      }
    });
    
    document.getElementById('btnConfirmCommentDelete').addEventListener('click', async () => {
      try {
        await apiFetch(`/posts/${postId}/comments/${deleteCommentId}`, { method: 'PUT' });
        document.getElementById('commentDeleteModal').style.display = 'none';
        commentCurrentPage = 0;
        hasMoreComments = true;
        await loadComments(true);
        await loadPost();
      } catch (e) {
        alert('댓글 삭제에 실패했습니다: ' + e.message);
      }
    });
    
    // 모달 닫기
    document.getElementById('btnCancelDelete').addEventListener('click', () => {
      document.getElementById('deleteModal').style.display = 'none';
    });
    
    document.getElementById('btnCancelCommentDelete').addEventListener('click', () => {
      document.getElementById('commentDeleteModal').style.display = 'none';
    });
    
    // 모달 배경 클릭으로 닫기
    document.getElementById('deleteModal').addEventListener('click', (e) => {
      if (e.target.id === 'deleteModal') {
        document.getElementById('deleteModal').style.display = 'none';
      }
    });
    
    document.getElementById('commentDeleteModal').addEventListener('click', (e) => {
      if (e.target.id === 'commentDeleteModal') {
        document.getElementById('commentDeleteModal').style.display = 'none';
      }
    });
    
    // 게시글 수정
    document.getElementById('btnEdit').addEventListener('click', () => {
      location.href = '/posts/new?id=' + postId;
    });
    
    // 초기 로드
    loadPost();
    
    // 댓글 섹션 스크롤 리스너 설정
    setupCommentScrollListener();
  </script>
</body>
</html>
